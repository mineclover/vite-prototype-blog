---
title: 단어 검색 인덱싱 적용 알고리즘 만들기
sidebar_position: 2.3
date: 2023-03-30
modified: 2023-04-30
---

## 단어 검색 인덱싱 적용 알고리즘 만들기

> [!done] 상황
> 프로젝트 진행 중에
> 무작위 스크립트에서 단어에서 일치하는 단어가 있으면 자동으로 미리 다른 컴포넌트로 바꾸는 기능을 구현하려함
> ( 등기부등본에 사용하는 전문용어를 찾아서 표시하려 함 )

질문 스크립트를 만들긴 했는데 질문은 안했다
답을 정해놓고 질문 한 것 같아서..

> [!NOTE] 질문
> 저 무작위 스크립트에서 특정단어가 있으면 컴포넌트화 시키는 기능을 구현하려하는데 ..
> IDE 같은 거에서는 검색하는 건 .이나 공백 / 처럼 분명한 구분단위가 있어서 검색 구분이 쉬운편인데
> 무작위 스크립트에서 저장된 단어를 찾는 건 소모 자원이 높을 것 같아서 인덱싱 알고리즘 적용을 하려합니다만 낭비일까요
> 그냥 .includes 랑 find 쓸까요 성능 비교해볼만한 것 같긴 한데
> 해당 메서드와 인덱싱으로 만들어진 검색 엔진 [GitHub - lucaong/minisearch: Tiny and powerful JavaScript full-text search engine for browser and Node](https://github.com/lucaong/minisearch)

단어 검색에서 array 랑 string 내장 메서드로 검사 시 656! x 단어의 텍스트 갯수! x 검사할 글자수의 n!
의 시간복잡도를 가지기 때문에 좀 간략한 검색을 할 수 있도록 최적화해주는건 어떨지 !

> [!NOTE] 기능 개발을 제안한 이유
> 내장 메서드의 단어 탐색 방식이 어떻게 되는지 모르겠지만
> 완전탐색한다고 할 때 인덱싱을 구성해서 반복 횟수를 줄이는 것도 유효하게 판단됬었다

내가 생각한 거는 찾고자 하는 글자의 앞글자 랑 글자 개수 그런 걸로 인덱싱을 먼저 하고
글자 수가 얼마 되지 않으면은 자음 글자 수가 조금 많으면은 자음 모음 글자 수가 아주 많으면 받침까지!
영어는 대소문자 구분하지 않는 게 좋아 보이고 ( 대소문자로 뜻이 달라지진 않으므로 )
뎁스 단위로 result 를 둬서 현재 깊이 검색의 총 갯수를 항상 보여지게 할 것

단어를 단어 길이별로 또 쪼갤 수 있다
그래서 찾고자하는 단어의 시작과 끝을 검색해서 숫자로 찾았을 때
해당 갯수에 포함되는 단어가 없다면 더 이상 탐색하지 않고 다음 단계로 들어간다

> [!NOTE] 분산처리 검토
> 배열 나누듯 자음들을 쪼개서 한번에 보내고 있는 개체에서만 찾는 것을 검토했었다
>
> 노드 싱글 스레드니까 프로미스로 연산하는 거 기능 만들어서 파트 쪼개서 연산하면 성능 최적화 효과가 없다
> 외부 요청 보내고 대기하는 경우도 없고 내부연산으로 끝나기 때문에...
> 서버나 파일로 I/O 가 있어서 블로킹땜에 성능을 온전히 못 뽑고 있는경우 데이터베이스를 관리한다면 프로미스로 계산하게 할 수 있긴 할 것 같다

> [!NOTE] 인덱싱 순서
> 자음 > 최대 글자 갯수 > 모음 > 최대 글자 갯수 > 받침 > 최대 글자 갯수

순열탐색을 할 경우 처음 단어를 찝고 자음으로 자음을 봤을 때 그 자음의 최대 글자갯수가 4 개면 단어 검색도 4 개까지 할 수 있는데
만약 `가나다는 한글을 배우는 국민 동요 "가나다 송"의 첫 세글자다` 에서 가나다를 표시하는 과정

단얼를 순서대로 탐색함
가 를 인식한 알고리즘은 가를 처음엔 ㄱ로 인식하고 ㄱ에 대한 조회를 한다
이후 그 객체 안에 저장된 객체들에서 순서대로 가 갸 거 겨로 데이터를 순회한다
가에 저장된 값으로 값이 있는 지 없는지를 확인하고 있으면 계속 탐색한다
찾는 단어인 " 가 " 와 = 원래 있던 " 가 " 가 만났기 때문에 더 이상 깊이 탄색은 안해도 된다

ㄱ 로 찾으면 max : 4 , min : 1 , result : 100
가 로 찾으면 max : 3 , result : 4
그래서 가에 저장되있는 단어들을 찾고 ... 결론적으로 words : [ " 가나다 ", " 가붕이 " , " 가구 ", " 가 "] 에서 맞는 단어를 찾는다

만약 글자 숫자 단위로 또 객체를 나누게 되면 단어 숫자단위로 쿼리해서
길이가 3 인 배열에서만 필요한 단어를 찾도록...
내가 궁금한 것은 `'abc' === 'abc' , 'abc'[0] === 'a' ` 에서 뭐가 더 빠르냐 인 것임
이 것에 대해서는 아예 값을 숫자로 바꾼다음 찾아버리는 검색 방식도 존재하였음

이렇게 하면 비용이 줄지 않을까
result 로 한번 더 줄이고 return 시키기 때문에

단어들을 엔진으로 돌렸을 때 인덱싱된 객체 를 통해서 값들이 얼마나 저장이 되어 있는지
먼저 찾아보내고
일치하는 영역이 있을 경우에 그 단어로 시작하는 단어가 있는지 찾아보고
없으면 찾지 않고 다음 단어를 추적
이렇게 하면은 전체 단어수 (n) x index 노드 숫자 (n) x 내부의 단어 숫자 (n) 으로 줄어듬 > 이게 맞나?

키 - 벨류 = 단어 : 뜻 의 데이터가 있다는 것을 전재로
단어들의 리스트만을 가지고 먼저 인덱싱한다

그래서 결과적으로 내가 생각하는 단어가 있는지 찾아내서 그 단어를 표시하는 것에 목적이 있다
만약 이미 일치하는 단어가 있다면 그 단어는 더 이상 검사 하면 안된다

즉 긴 단어 순서로 검색하면 좋을 것으로 보인다

내가 생각하는 만큼의 연산 감소가 발생하는지의 여부는 파악이 필요하다

[[단어-찾기-질문]]
